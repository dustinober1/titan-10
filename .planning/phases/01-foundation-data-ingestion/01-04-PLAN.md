---
phase: 01-foundation-data-ingestion
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - "src/ingestor/redundancy.py"
  - "src/ingestor/fetcher.py"
autonomous: false
user_setup: []

must_haves:
  truths:
    - "System fetches data from multiple exchanges for redundancy"
    - "Per-exchange data is stored separately with exchange identifier"
    - "Data normalization handles exchange-specific timestamp differences"
    - "Primary/secondary exchange selection prevents over-fetching"
    - "System degrades gracefully when exchanges are unavailable"
  artifacts:
    - path: "src/ingestor/redundancy.py"
      provides: "Multi-exchange redundancy and failover logic"
      exports: ["RedundantFetcher", "select_primary_exchange"]
    - path: "src/ingestor/fetcher.py"
      provides: "Updated fetcher with multi-exchange support"
      exports: ["fetch_multi_exchange_ohlcv"]
  key_links:
    - from: "src/ingestor/redundancy.py"
      to: "src/ingestor/exchange.py"
      via: "ExchangeWrapper instances for multiple exchanges"
      pattern: "ExchangeWrapper\\("
    - from: "src/ingestor/redundancy.py"
      to: "src/storage/connection.py"
      via: "DatabasePool.insert_ohlcv with OHLCVData.exchange field"
      pattern: "insert_ohlcv.*exchange"
    - from: "src/ingestor/fetcher.py"
      to: "src/ingestor/redundancy.py"
      via: "RedundantFetcher for multi-exchange fetching"
      pattern: "RedundantFetcher\\("
    - from: "src/ingestor/normalizer.py"
      to: "src/storage/connection.py"
      via: "OHLCVData.exchange field in insert_ohlcv calls"
      pattern: "OHLCVData.*exchange="
---

<objective>
Implement multi-exchange redundancy with per-exchange data storage and graceful degradation.

Purpose: Ensure data availability and reliability by fetching from multiple cryptocurrency exchanges. When one exchange fails, others provide data, preventing single points of failure.
Output: Working multi-exchange system that stores per-exchange data and handles failures gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-ingestion/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation-data-ingestion/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RedundantFetcher for multi-exchange coordination</name>
  <files>
    src/ingestor/redundancy.py
  </files>
  <action>
    Create RedundantFetcher class following multi-exchange patterns from research:

    1. src/ingestor/redundancy.py:
       - Import ExchangeWrapper from src.ingestor.exchange
       - Import OHLCVData from src.ingestor.normalizer
       - Import logging, asyncio
       - Define RedundantFetcher class with __init__(exchanges: list[str])
       - In __init__: store exchanges list, create dict of ExchangeWrapper instances (lazy initialization)
       - Define async fetch_from_exchange method: exchange_id (str), symbol (str)
       - In fetch_from_exchange:
         * Instantiate ExchangeWrapper if not exists in wrappers dict
         * Fetch OHLCV via await exchange.fetch_ohlcv(symbol, '1d')
         * Normalize data using OHLCVData validation with exchange field set to exchange_id
         * Return list of validated OHLCVData objects
         * Handle exceptions: log error, return empty list (graceful degradation)
       - Define async fetch_all_exchanges method: symbol (str)
       - In fetch_all_exchanges:
         * Create tasks list: [fetch_from_exchange(exch, symbol) for exch in self.exchanges]
         * Use asyncio.gather(*tasks, return_exceptions=True)
         * Process results: separate successes from failures
         * Return dict: {exchange_id: list[OHLCVData]}
       - Define get_successful_exchanges method accepting results from fetch_all_exchanges
       - In get_successful_exchanges: return list of exchange IDs with non-empty data

    Reference: Code Examples section (multi-exchange fetching), AUTO-03 requirement (graceful degradation)
  </action>
  <verify>
    Run: python -c "from src.ingestor.redundancy import RedundantFetcher; print(RedundantFetcher.__doc__)"
    Check: RedundantFetcher has fetch_all_exchanges and get_successful_exchanges methods
  </verify>
  <done>
    RedundantFetcher coordinates multiple exchanges, returns per-exchange data with error isolation
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement primary exchange selection and data merging</name>
  <files>
    src/ingestor/redundancy.py
  </files>
  <action>
    Add exchange selection and data merging logic to src/ingestor/redundancy.py:

    1. Add to src/ingestor/redundancy.py:
       - Define select_primary_exchange function accepting: symbol (str), available_exchanges (list[str])
       - In select_primary_exchange:
         * Define exchange priority list: ['binance', 'coinbase', 'kraken', 'okx', 'bybit'] (most liquid first)
         * Find first available exchange in priority list
         * Return primary exchange ID or None if no matches
       - Define merge_ohlcv_data function accepting: per_exchange_data (dict[str, list[OHLCVData]])
       - In merge_ohlcv_data:
         * Get primary exchange via select_primary_exchange
         * If primary exists and has data: use primary exchange data
         * If no primary: use first available exchange with data
         * If no data: return empty list
         * Return selected exchange's OHLCVData list
         * Note: For Phase 1, store per-exchange data separately (merging at query time in Phase 2)
       - Define async fetch_with_redundancy method in RedundantFetcher class: symbol (str), storage (DatabasePool)
       - In fetch_with_redundancy:
         * Call fetch_all_exchanges(symbol) to get per-exchange data
         * Get successful exchanges list
         * Log results: "{len(successful)} exchanges returned data for {symbol}"
         * Store per-exchange data: iterate through results, await storage.insert_ohlcv for each OHLCVData list
         * Note: OHLCVData.exchange field (from plan 01-02) carries the exchange identifier to storage
         * Return primary exchange data via merge_ohlcv_data

    Reference: Open Question 2 (multi-exchange merging strategy), DATA-02 requirement (multi-exchange redundancy)
  </action>
  <verify>
    Run: python -c "from src.ingestor.redundancy import select_primary_exchange, merge_ohlcv_data; print(select_primary_exchange.__doc__)"
    Check: Functions exist with correct signatures
  </verify>
  <done>
    select_primary_exchange prioritizes exchanges by liquidity, merge_ohlcv_data selects best data source
  </done>
</task>

<task type="auto">
  <name>Task 3: Update fetcher for multi-exchange integration</name>
  <files>
    src/ingestor/fetcher.py
  </files>
  <action>
    Refactor src/ingestor/fetcher.py to use RedundantFetcher:

    1. Update src/ingestor/fetcher.py:
       - Import RedundantFetcher from src.ingestor.redundancy
       - Define fetch_multi_exchange_ohlcv function accepting: symbols (list[str]), exchanges (list[str]), storage (DatabasePool)
       - In fetch_multi_exchange_ohlcv:
         * Create RedundantFetcher instance with exchanges list
         * Iterate through symbols
         * For each symbol: await fetcher.fetch_with_redundancy(symbol, storage)
         * Handle exceptions: log error per symbol, continue to next (graceful degradation)
       - Refactor existing fetch_realtime_ohlcv to call fetch_multi_exchange_ohlcv
       - Update fetch_single_symbol to use RedundantFetcher instead of direct ExchangeWrapper
       - Add logging for multi-exchange success rates

    Reference: Pattern 3 (APScheduler integration), AUTO-03 requirement (partial failures)
  </action>
  <verify>
    Run: python -c "from src.ingestor.fetcher import fetch_multi_exchange_ohlcv; print(fetch_multi_exchange_ohlcv.__doc__)"
    Check: Function uses RedundantFetcher for multi-exchange coordination
  </verify>
  <done>
    fetch_multi_exchange_ohlcv uses RedundantFetcher, stores per-exchange data via OHLCVData.exchange field, handles partial failures
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete multi-exchange redundancy system with per-exchange storage</what-built>
  <how-to-verify>
    1. Ensure TimescaleDB is running and DATABASE_URL is configured
    2. Start scheduler with multi-exchange support: `python -c "import asyncio; from src.ingestor.scheduler import IngestionScheduler; from src.storage.connection import DatabasePool; from src.shared.config import get_settings; async def run(): pool = DatabasePool(get_settings().database_url); await pool.init(); scheduler = IngestionScheduler(pool); scheduler.start(); import signal; signal.pause(); asyncio.run(run())"`
    3. Monitor logs for multi-exchange fetching:
       - "X exchanges returned data for BTC/USDT"
       - Per-exchange success/failure indicators
    4. Verify per-exchange storage in database: Run `psql -c "SELECT exchange, symbol, COUNT(*) FROM ohlcv WHERE symbol = 'BTC/USDT' GROUP BY exchange, symbol;"`
    5. Test graceful degradation:
       - Temporarily disconnect one exchange (add invalid exchange to list)
       - Confirm system continues with remaining exchanges
       - Check logs for degradation messages
    6. Verify data quality: Run `psql -c "SELECT exchange, symbol, time, close FROM ohlcv WHERE symbol = 'BTC/USDT' ORDER BY time DESC LIMIT 20;"`
  </how-to-verify>
  <resume-signal>Type "approved" if multi-exchange redundancy works with graceful degradation, or describe issues</resume-signal>
</task>

</tasks>

<verification>
## Automated Verification (Before Checkpoint)

1. **Module Import**: Run `python -c "from src.ingestor.redundancy import RedundantFetcher, select_primary_exchange, merge_ohlcv_data"` to confirm modules load
2. **Exchange Selection**: Run `python -c "from src.ingestor.redundancy import select_primary_exchange; print(select_primary_exchange('BTC/USDT', ['binance', 'kraken']))"` to verify priority logic
3. **Per-Exchange Storage**: Run `python -c "from src.ingestor.fetcher import fetch_multi_exchange_ohlcv; import inspect; print('exchange' in inspect.getsource(fetch_multi_exchange_ohlcv))"` to confirm exchange handling via OHLCVData.exchange field

## Checkpoint Verification (Human)

4. **Multi-Exchange Execution**: Run scheduler and confirm:
   - Data is fetched from multiple exchanges
   - Per-exchange data is stored with exchange identifier
   - Logs show exchange success rates
5. **Graceful Degradation**: Test with unavailable exchanges:
   - System continues with available exchanges
   - No crashes when exchanges fail
   - Error logs indicate which exchanges failed
6. **Data Verification**: Confirm database contains per-exchange data (exchange column populated)

## Success Criteria
- [ ] RedundantFetcher fetches from multiple exchanges concurrently
- [ ] Per-exchange data is stored with exchange identifier in database (via OHLCVData.exchange field)
- [ ] select_primary_exchange prioritizes exchanges by liquidity
- [ ] System continues operating when exchanges are unavailable
- [ ] Logs indicate per-exchange success/failure rates
- [ ] Data normalization handles exchange-specific timestamp formats
</verification>

<success_criteria>
1. RedundantFetcher coordinates multi-exchange fetching with error isolation
2. Per-exchange OHLCV data is stored separately using OHLCVData.exchange field (defined in plan 01-02)
3. Primary exchange selection prioritizes liquidity (Binance > Coinbase > Kraken > OKX > Bybit)
4. Graceful degradation allows system to function with subset of exchanges
5. asyncio.gather enables concurrent fetching from all exchanges
6. fetch_multi_exchange_ohlcv integrates RedundantFetcher into scheduler
7. Human verification confirms per-exchange data storage and graceful degradation
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-ingestion/01-04-SUMMARY.md` with:
- Multi-exchange implementation status (exchanges supported, priority order)
- Per-exchange storage verification results (OHLCVData.exchange field usage)
- Graceful degradation test results
- Next steps ready for 01-05 (autonomous error handling)
</output>
