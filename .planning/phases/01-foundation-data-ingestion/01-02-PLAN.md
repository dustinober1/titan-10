---
phase: 01-foundation-data-ingestion
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - "src/ingestor/__init__.py"
  - "src/ingestor/exchange.py"
  - "src/ingestor/fetcher.py"
  - "src/ingestor/normalizer.py"
  - "src/ingestor/scheduler.py"
autonomous: true
user_setup: []

must_haves:
  truths:
    - "CCXT exchange wrapper instantiates and connects to exchanges"
    - "Real-time OHLCV data can be fetched from configured exchanges"
    - "Fetched data is validated against OHLCV constraints (high >= low, no negative prices)"
    - "Validated data is persisted to TimescaleDB hypertable"
    - "Scheduler triggers periodic data fetching every 60 seconds"
  artifacts:
    - path: "src/ingestor/exchange.py"
      provides: "CCXT exchange wrapper with rate limiting"
      exports: ["ExchangeWrapper"]
    - path: "src/ingestor/fetcher.py"
      provides: "OHLCV fetching logic with multi-exchange support"
      exports: ["fetch_realtime_ohlcv", "fetch_single_symbol"]
    - path: "src/ingestor/normalizer.py"
      provides: "Data validation using Pydantic models"
      exports: ["OHLCVData", "validate_ohlcv"]
    - path: "src/ingestor/scheduler.py"
      provides: "APScheduler job scheduling for periodic fetching"
      exports: ["IngestionScheduler", "start_scheduler"]
  key_links:
    - from: "src/ingestor/exchange.py"
      to: "CCXT exchange APIs"
      via: "ccxt.async_support module"
      pattern: "import ccxt\\.async_support"
    - from: "src/ingestor/fetcher.py"
      to: "src/storage/connection.py"
      via: "DatabasePool.insert_ohlcv method"
      pattern: "await.*\\.insert_ohlcv\\("
    - from: "src/ingestor/normalizer.py"
      to: "Pydantic validation"
      via: "pydantic.BaseModel validation"
      pattern: "OHLCVData\\("
    - from: "src/ingestor/scheduler.py"
      to: "APScheduler AsyncIOScheduler"
      via: "AsyncIOScheduler instance"
      pattern: "AsyncIOScheduler\\(\\)"
---

<objective>
Integrate CCXT library for multi-exchange cryptocurrency data fetching with real-time ingestion pipeline.

Purpose: Enable autonomous fetching of OHLCV data from cryptocurrency exchanges using CCXT's unified API. This is the core data ingestion pipeline that powers the entire system.
Output: Working exchange integration that fetches, validates, and stores real-time market data every 60 seconds.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-ingestion/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-foundation-data-ingestion/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CCXT exchange wrapper with rate limiting</name>
  <files>
    src/ingestor/__init__.py
    src/ingestor/exchange.py
  </files>
  <action>
    Implement ExchangeWrapper class following Pattern 1 from research:

    1. src/ingestor/__init__.py:
       - Export ExchangeWrapper, fetcher, normalizer, scheduler modules

    2. src/ingestor/exchange.py:
       - Import ccxt.async_support as ccxt (NOT ccxt module - anti-pattern from research)
       - Import tenacity decorators (@retry, stop_after_attempt, wait_exponential)
       - Define ExchangeWrapper class with __init__(exchange_id: str, api_key: str = None, secret: str = None)
       - In __init__: instantiate exchange using getattr(ccxt, exchange_id) with config dict containing:
         * 'apiKey': api_key, 'secret': secret
         * 'enableRateLimit': True (CRITICAL - prevents IP bans per Pitfall 1)
         * 'options': {'defaultType': 'spot'}
       - Add @retry decorator to fetch_ohlcv method: stop=stop_after_attempt(5), wait=wait_exponential(multiplier=1, min=1, max=60)
       - Implement async fetch_ohlcv(symbol: str, timeframe: str = '1d', since: int = None, limit: int = 1000) -> list
       - In fetch_ohlcv: wrap exchange.fetch_ohlcv in try/except, catch ccxt.NetworkError (retry) and ccxt.ExchangeError (log, return empty list)
       - Implement async close() method to call await self.exchange.close()

    Reference: Pattern 1 (async wrapper), Pitfall 1 (rate limit IP bans), Anti-Patterns section
  </action>
  <verify>
    Run: python -c "from src.ingestor.exchange import ExchangeWrapper; print(ExchangeWrapper.__doc__)"
    Check: Module imports without errors, ExchangeWrapper has fetch_ohlcv method
  </verify>
  <done>
    ExchangeWrapper instantiates exchanges with rate limiting enabled, implements retry with exponential backoff
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OHLCV data fetching with multi-exchange support</name>
  <files>
    src/ingestor/fetcher.py
  </files>
  <action>
    Create fetching logic using asyncio for concurrent multi-exchange operations:

    1. src/ingestor/fetcher.py:
       - Define fetch_realtime_ohlcv function accepting: symbols (list[str]), exchanges (list[str]), storage (DatabasePool)
       - In fetch_realtime_ohlcv: create list of tasks calling fetch_single_symbol for each symbol
       - Use asyncio.gather(*tasks, return_exceptions=True) to fetch concurrently with error isolation
       - Log successes and failures separately
       - Define async fetch_single_symbol function: symbol, exchanges, storage
       - In fetch_single_symbol: create ExchangeWrapper instances for each exchange, await fetch_ohlcv, await storage.insert_ohlcv, await exchange.close()
       - Handle exceptions per-exchange (don't let one exchange failure stop others)
       - Use '1d' timeframe for daily candles (Phase 1 scope)

    Reference: Pattern 3 (APScheduler), Code Examples section (multi-exchange fetching)
  </action>
  <verify>
    Run: python -c "from src.ingestor.fetcher import fetch_realtime_ohlcv; print(fetch_realtime_ohlcv.__doc__)"
    Check: Function signature includes symbols, exchanges, storage parameters
  </verify>
  <done>
    fetch_realtime_ohlcv fetches from multiple exchanges concurrently using asyncio.gather
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement data normalization and validation</name>
  <files>
    src/ingestor/normalizer.py
  </files>
  <action>
    Create Pydantic models for OHLCV validation following research Code Examples:

    1. src/ingestor/normalizer.py:
       - Import pydantic (BaseModel, Field, validator)
       - Define OHLCVData class extending BaseModel with fields:
         * timestamp: int
         * symbol: str
         * exchange: str
         * open: float = Field(gt=0) (must be positive)
         * high: float = Field(gt=0)
         * low: float = Field(gt=0)
         * close: float = Field(gt=0)
         * volume: float = Field(ge=0) (can be zero)
       - Add @validator for 'high': check if 'low' in values, raise ValueError if high < low
       - Add @validator for 'low': check if 'high' in values, raise ValueError if low > high
       - Add @validator for 'open', 'close': check if within high/low range
       - Define validate_ohlcv function: accepts list of raw CCXT candle tuples, returns list of validated OHLCVData objects
       - In validate_ohlcv: iterate candles, construct dict with timestamp, symbol, exchange, OHLCV values, try OHLCVData(**data), catch ValidationError and log
       - Return list of valid OHLCVData objects

    Reference: Data Validation with Pydantic example from research
  </action>
  <verify>
    Run: python -c "from src.ingestor.normalizer import OHLCVData; o = OHLCVData(timestamp=1, symbol='BTC/USDT', exchange='binance', open=1, high=2, low=1, close=1.5, volume=100); print(o)"
    Check: Valid OHLCV data passes validation
  </verify>
  <done>
    OHLCVData validates price constraints (high >= low, prices within range), catches invalid data
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement APScheduler for periodic data fetching</name>
  <files>
    src/ingestor/scheduler.py
  </files>
  <action>
    Create scheduler using APScheduler AsyncIOScheduler following Pattern 3 from research:

    1. src/ingestor/scheduler.py:
       - Import AsyncIOScheduler from apscheduler.schedulers.asyncio
       - Import get_settings from src.shared.config
       - Import fetch_realtime_ohlcv from src.ingestor.fetcher
       - Import DatabasePool from src.storage.connection
       - Define IngestionScheduler class with __init__(storage: DatabasePool)
       - In __init__: create AsyncIOScheduler(), store storage reference, load settings
       - Define async fetch_realtime_data method: get top_symbols from settings, call fetch_realtime_ohlcv(symbols, ['binance'], storage)
       - Define start method:
         * Add job: scheduler.add_job(self.fetch_realtime_data, 'interval', seconds=60, id='realtime_ingestion', replace_existing=True)
         * Call scheduler.start()
         * Log "Scheduler started" message
       - Define stop method: scheduler.shutdown(wait=False)
       - Define start_scheduler convenience function: creates IngestionScheduler, calls start()

    Reference: Pattern 3 (APScheduler AsyncIOScheduler), Success Criteria (60-second intervals)
  </action>
  <verify>
    Run: python -c "from src.ingestor.scheduler import IngestionScheduler; print(IngestionScheduler.__doc__)"
    Check: IngestionScheduler class exists with start and stop methods
  </verify>
  <done>
    IngestionScheduler starts AsyncIOScheduler with 60-second interval job for real-time fetching
  </done>
</task>

</tasks>

<verification>
## Plan Verification

1. **Module Import**: Run `python -c "from src.ingestor import ExchangeWrapper, fetch_realtime_ohlcv, validate_ohlcv, IngestionScheduler"` to confirm all modules load
2. **Exchange Wrapper**: Run `python -c "from src.ingestor.exchange import ExchangeWrapper; e = ExchangeWrapper('binance'); print(hasattr(e, 'fetch_ohlcv'))"` to verify wrapper structure
3. **Data Validation**: Run test with invalid OHLCV (high < low) to confirm Pydantic validation catches it
4. **Scheduler**: Run `python -c "from src.ingestor.scheduler import IngestionScheduler; print(IngestionScheduler.__doc__)"` to verify scheduler can be instantiated

## Success Criteria
- [ ] ExchangeWrapper instantiates exchanges with enableRateLimit=True
- [ ] fetch_ohlcv method has @retry decorator with exponential backoff
- [ ] fetch_realtime_ohlcv uses asyncio.gather for concurrent fetching
- [ ] OHLCVData validates high >= low constraint
- [ ] IngestionScheduler schedules jobs with 60-second interval
- [ ] All modules import without errors
</verification>

<success_criteria>
1. CCXT async_support module is used (not synchronous ccxt)
2. ExchangeWrapper implements rate limiting via enableRateLimit=True
3. Tenacity @retry decorator provides exponential backoff (1s min, 60s max)
4. Pydantic OHLCVData model validates OHLCV constraints (positive prices, high >= low)
5. asyncio.gather enables concurrent multi-exchange fetching with error isolation
6. APScheduler AsyncIOScheduler triggers fetch_realtime_data every 60 seconds
7. Normalizer converts CCXT tuples to validated OHLCVData objects
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-ingestion/01-02-SUMMARY.md` with:
- CCXT integration status (exchanges supported, rate limiting)
- Validation rules enforced (OHLCV constraints)
- Concurrency implementation (asyncio.gather pattern)
- Next steps ready for 01-03 (historical backfill)
</output>
